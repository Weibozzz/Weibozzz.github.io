"use strict";(self.webpackChunkweiboqianduan=self.webpackChunkweiboqianduan||[]).push([[61],{3911:(e,a,s)=>{s.r(a),s.d(a,{data:()=>n});const n={key:"v-c5a73bb0",path:"/Utils/Git/%E4%BD%A0%E6%83%B3%E8%A6%81%E7%9A%84git%E9%83%BD%E6%9C%89.html",title:"你想要的git都有",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"git命令",slug:"git命令",children:[]},{level:2,title:"在Mac上配置全局的Git忽略文件",slug:"在mac上配置全局的git忽略文件",children:[]},{level:2,title:"获取",slug:"获取",children:[]},{level:2,title:"正常提交",slug:"正常提交",children:[]},{level:2,title:"初始化",slug:"初始化",children:[{level:3,title:"移仓库，同时保留原有的提交记录和分支",slug:"移仓库-同时保留原有的提交记录和分支",children:[]}]},{level:2,title:"版本回退",slug:"版本回退",children:[{level:3,title:"删除之前的提交记录",slug:"删除之前的提交记录",children:[]}]},{level:2,title:"工作区和暂存区",slug:"工作区和暂存区",children:[]},{level:2,title:"撤销修改",slug:"撤销修改",children:[{level:3,title:"丢弃文件命令",slug:"丢弃文件命令",children:[]},{level:3,title:"将当前提交撤回到commitB_hash",slug:"将当前提交撤回到commitb-hash",children:[]},{level:3,title:"将工作区，暂存区强制恢复成 commitB_hash的状态",slug:"将工作区-暂存区强制恢复成-commitb-hash的状态",children:[]}]},{level:2,title:"git stash用法",slug:"git-stash用法",children:[{level:3,title:"保存当前修改",slug:"保存当前修改",children:[]},{level:3,title:"重新应用缓存的stash",slug:"重新应用缓存的stash",children:[]},{level:3,title:"查看现有stash",slug:"查看现有stash",children:[]},{level:3,title:"恢复 stash",slug:"恢复-stash",children:[]}]},{level:2,title:"删除文件",slug:"删除文件",children:[]},{level:2,title:"分支管理",slug:"分支管理",children:[{level:3,title:"修改分支",slug:"修改分支",children:[]},{level:3,title:"混乱的分支",slug:"混乱的分支",children:[]},{level:3,title:"Git创建一个空分支",slug:"git创建一个空分支",children:[]}]},{level:2,title:"git提交空文件夹",slug:"git提交空文件夹",children:[]},{level:2,title:"gerrit",slug:"gerrit",children:[{level:3,title:"常见报错",slug:"常见报错",children:[]}]},{level:2,title:"小结",slug:"小结",children:[{level:3,title:"误删分支",slug:"误删分支",children:[]}]},{level:2,title:"自定义Git",slug:"自定义git",children:[]},{level:2,title:"其它技巧",slug:"其它技巧",children:[{level:3,title:"忽略操作系统尾部换行符",slug:"忽略操作系统尾部换行符",children:[]}]},{level:2,title:"安全重命名",slug:"安全重命名",children:[]},{level:2,title:"并入你最近的一次 commit",slug:"并入你最近的一次-commit",children:[]},{level:2,title:"撤销远程操作",slug:"撤销远程操作",children:[]},{level:2,title:"git 子模块",slug:"git-子模块",children:[{level:3,title:"克隆所有子模块",slug:"克隆所有子模块",children:[]},{level:3,title:"添加",slug:"添加",children:[]},{level:3,title:"删除",slug:"删除",children:[]},{level:3,title:"下载的工程带有submodule",slug:"下载的工程带有submodule",children:[]},{level:3,title:"修改子模块并提交",slug:"修改子模块并提交",children:[]},{level:3,title:"添加ssh",slug:"添加ssh",children:[]},{level:3,title:"git 钩子",slug:"git-钩子",children:[]}]},{level:2,title:"今日图",slug:"今日图",children:[]}],filePathRelative:"Utils/Git/你想要的git都有.md",git:{updatedTime:1637917286e3}}},8894:(e,a,s)=>{s.r(a),s.d(a,{default:()=>$});var n=s(6252);const i=s.p+"assets/img/16a8d22958e71066.5f5afc4e.png",c=(0,n.uE)('<h1 id="你想要的git都有" tabindex="-1"><a class="header-anchor" href="#你想要的git都有" aria-hidden="true">#</a> 你想要的git都有</h1><h2 id="git命令" tabindex="-1"><a class="header-anchor" href="#git命令" aria-hidden="true">#</a> git命令</h2><h2 id="在mac上配置全局的git忽略文件" tabindex="-1"><a class="header-anchor" href="#在mac上配置全局的git忽略文件" aria-hidden="true">#</a> 在Mac上配置全局的Git忽略文件</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">vim</span> ~/.gitignore_global\n<span class="token function">git</span> config --global core.excludesfile ~/.gitignore_global\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="获取" tabindex="-1"><a class="header-anchor" href="#获取" aria-hidden="true">#</a> 获取</h2><p>这些在 <code>shell</code> 脚本中会很有用</p><ul><li>获取当前用户名：<code>git config user.name</code></li><li>获取当前分支: <code>git symbolic-ref --short HEAD</code></li><li>git获取最近一次提交的commit id:<code>git rev-parse HEAD</code></li><li>git获取tag最大值:&#39;git describe --tags <code>git rev-list --tags --max-count=1</code>&#39;</li><li>git获取所有tag(包括提交信息-n):<code>git tag -l -n</code></li><li>git获取某分支最近提交时间(处理一些僵尸分支):<code>git log -1 --date=iso &lt;branchName&gt;</code></li><li>显示所有远程分支 并且已合并到master分支的分支:<code>git branch -r --merged master</code></li></ul><h2 id="正常提交" tabindex="-1"><a class="header-anchor" href="#正常提交" aria-hidden="true">#</a> 正常提交</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>\n<span class="token function">git</span> commit -m <span class="token string">&quot;提交内容&quot;</span>\n<span class="token function">git</span> pull\n<span class="token function">git</span> push origin 分支名\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="初始化" tabindex="-1"><a class="header-anchor" href="#初始化" aria-hidden="true">#</a> 初始化</h2><p>设置用户名，邮箱</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> config --global user.name <span class="token string">&quot;Author Name&quot;</span>\n<span class="token function">git</span> config --global user.email <span class="token string">&quot;Author Email&quot;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>查看邮箱用户名等选项</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>gitc onfig --list\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>初始化一个Git仓库，使用<code>git init</code>命令。 第一步，使用命令<code>git add .</code>,添加全部 ，注意，可反复多次使用，添加多个文件； 第二步，使用命令<code>git commit -m &quot;提交的注释&quot;</code>，完成。</p><p>运行<code>git status</code>命令看看结果 运行<code>git diff</code>这个命令可查看我们修改了什么内容 第一步：<code>git add .</code> 第二步：<code>git commit -m &quot;写改动的注释&quot;</code></p><h3 id="移仓库-同时保留原有的提交记录和分支" tabindex="-1"><a class="header-anchor" href="#移仓库-同时保留原有的提交记录和分支" aria-hidden="true">#</a> 移仓库，同时保留原有的提交记录和分支</h3><p>https://github.com/haizlin/fe-interview/issues/2150</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>git clone --bare 旧库地址\ngit push --mirror 新库地址\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="版本回退" tabindex="-1"><a class="header-anchor" href="#版本回退" aria-hidden="true">#</a> 版本回退</h2><p>通过<code>git log</code>来查看版本（加上<code>--pretty=oneline</code>参数查看关键信息）： <code>git</code>中，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code>。</p><p><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。 穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p><h3 id="删除之前的提交记录" tabindex="-1"><a class="header-anchor" href="#删除之前的提交记录" aria-hidden="true">#</a> 删除之前的提交记录</h3><p>找到提交的<code>commit_id </code>, 先<code>git checkout &lt;commit_id&gt;</code>，然后<code>git push origin &lt;commit_id&gt; --force</code>,这个要慎重，删除了就没有了。</p><h2 id="工作区和暂存区" tabindex="-1"><a class="header-anchor" href="#工作区和暂存区" aria-hidden="true">#</a> 工作区和暂存区</h2><p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><h2 id="撤销修改" tabindex="-1"><a class="header-anchor" href="#撤销修改" aria-hidden="true">#</a> 撤销修改</h2>',27),d=(0,n._)("strong",null,"git reflog 记录每一次操作，可进行回滚",-1),t=(0,n._)("strong",null,"git 优雅的撤销中间某次提交？",-1),l={href:"https://blog.csdn.net/u013066244/article/details/79920012",target:"_blank",rel:"noopener noreferrer"},o=(0,n.Uk)("https://blog.csdn.net/u013066244/article/details/79920012"),r=(0,n.uE)('<p><strong>有时候我们希望只合并某个分支上的某次修改commit到指定的分支上.那么就可以使用<code>cherry-pick</code>命令来操作了.</strong></p><p>使用git log 查看提交的信息,记住commit id.</p><p>git checkout 要修改的分支</p><p>git cherry-pick 某个commit id // 把某个commit id的提交合并到当前分支.</p><p>在修改了文件之后，且还没有<code>add</code>之前，可执行以下命令丢弃工作区的修改。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">git</span> checkout –- readme.txt\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令</p><p>如果你想要修改，已经<code>git add</code>到暂存区，但还没有<code>commit</code>的内容。 我们可以用命令<code>git reset HEAD file</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">git</span> reset HEAD readme.txt\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p><h3 id="丢弃文件命令" tabindex="-1"><a class="header-anchor" href="#丢弃文件命令" aria-hidden="true">#</a> 丢弃文件命令</h3><ul><li><code>git checkout .</code> # 丢弃所有修改或删除，不影响新增或未跟踪的文件。会递归下级目录</li><li><code>git clean -nxdf</code> # dry-run，先看下即将删除那些文件，再执行下面的危险命令</li><li><code>git clean -df</code> # 删除所有未跟踪的文件和目录（不包含.gitignore的文件），危险命令</li><li><code>git clean -xdf</code> # 删除所有未跟踪的文件和目录（同时包含.gitignore的文件），危险命令</li></ul><h3 id="将当前提交撤回到commitb-hash" tabindex="-1"><a class="header-anchor" href="#将当前提交撤回到commitb-hash" aria-hidden="true">#</a> 将当前提交撤回到commitB_hash</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> reset –-hard commitB_hash\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="将工作区-暂存区强制恢复成-commitb-hash的状态" tabindex="-1"><a class="header-anchor" href="#将工作区-暂存区强制恢复成-commitb-hash的状态" aria-hidden="true">#</a> 将工作区，暂存区强制恢复成 commitB_hash的状态</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> reset  commitB_hash\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div>',16),h={href:"https://segmentfault.com/a/1190000011969554#articleHeader7",target:"_blank",rel:"noopener noreferrer"},p=(0,n.Uk)("Git的4个阶段的撤销更改"),u=(0,n.uE)('<h2 id="git-stash用法" tabindex="-1"><a class="header-anchor" href="#git-stash用法" aria-hidden="true">#</a> git stash用法</h2><h3 id="保存当前修改" tabindex="-1"><a class="header-anchor" href="#保存当前修改" aria-hidden="true">#</a> 保存当前修改</h3><p><code>git stash</code> 会把所有未提交的修改（包括暂存的和非暂存的）都保存起来，用于后续恢复当前工作目录。<code>stash</code> 是本地的，不会通过 <code>git push</code> 命令上传到 <code>git server</code> 上。</p><h3 id="重新应用缓存的stash" tabindex="-1"><a class="header-anchor" href="#重新应用缓存的stash" aria-hidden="true">#</a> 重新应用缓存的stash</h3><p>可以通过 <code>git stash pop</code> 命令恢复之前缓存的工作目录，这个指令将缓存堆栈中的第一个stash删除，并将对应修改应用到当前的工作目录下</p><p>或者 <code>git stash apply {stashID}</code></p><h3 id="查看现有stash" tabindex="-1"><a class="header-anchor" href="#查看现有stash" aria-hidden="true">#</a> 查看现有stash</h3>',7),g=(0,n.Uk)("可以使用 "),b=(0,n._)("code",null,"git stash list",-1),m=(0,n.Uk)(" 命令， 点击查看"),v={href:"https://www.cnblogs.com/tocy/p/git-stash-reference.html",target:"_blank",rel:"noopener noreferrer"},f=(0,n.Uk)("更多stash用法"),k=(0,n.Uk)("。"),x=(0,n.uE)('<h3 id="恢复-stash" tabindex="-1"><a class="header-anchor" href="#恢复-stash" aria-hidden="true">#</a> 恢复 stash</h3><p>使用 <code>git stash clear</code> 误删除找回</p><p><code>git log --graph --oneline --decorate $( git fsck --no-reflog | awk &#39;/dangling commit/ {print $3}&#39;)</code> 调出 <code>stash</code> 的 <code>log</code>，该 <code>log</code> 对应 <code>stash</code> 的栈缓存纪录，<code>WIP</code> 为 <code>midify</code> 内容，<code>index</code> 为 <code>add</code> 内容，所以，一般情况下，<code>WIP</code> 比 <code>index</code> 内容要全</p><p>然后执行 <code>git stash apply {id}</code> 恢复最后 <code>stash</code> 的内容 至此，<code>stash</code> 被删除的内容全部被找回</p><h2 id="删除文件" tabindex="-1"><a class="header-anchor" href="#删除文件" aria-hidden="true">#</a> 删除文件</h2><p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">rm</span> test.txt\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>这个时候，<code>Git</code>知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了： 现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：</p><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">git</span> checkout -- test.txt\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><h2 id="分支管理" tabindex="-1"><a class="header-anchor" href="#分支管理" aria-hidden="true">#</a> 分支管理</h2><p>git查看当前分支所属</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> branch -vv\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>创建与合并分支 首先创建<code>dev</code>分支，然后切换到<code>dev</code>分支</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">git</span> checkout –b dev\n<span class="token function">git</span> checkout - <span class="token comment">#(-代表上一个分支名，这里是简写)</span>\nSwitched to a new branch <span class="token string">&#39;dev&#39;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">git</span> branch dev\n$ <span class="token function">git</span> checkout dev\n<span class="token comment"># Switched to branch &#39;dev&#39;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>git branch –a</code> 查看当前仓库的所有分支；<code>git branch –r</code>查看远程仓库的所有分支</p><p><code>dev</code>分支的工作成果合并到<code>master</code>分支上：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">git</span> merge dev\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="修改分支" tabindex="-1"><a class="header-anchor" href="#修改分支" aria-hidden="true">#</a> 修改分支</h3><p>如果对于分支不是当前分支，可以使用下面代码：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code> <span class="token function">git</span> branch -m 原名 新\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>如果是当前，那么可以使用加上新名字</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> branch -m 原名\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="混乱的分支" tabindex="-1"><a class="header-anchor" href="#混乱的分支" aria-hidden="true">#</a> 混乱的分支</h3><p>报错<code>$ git checkout -b *** fatal: cannot lock ref &#39;refs/heads/***&#39;: &#39;refs/heads/***&#39; exists; cannot create &#39;refs/heads/user/***&#39;</code></p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> remote prune origin\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="git创建一个空分支" tabindex="-1"><a class="header-anchor" href="#git创建一个空分支" aria-hidden="true">#</a> Git创建一个空分支</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> checkout --orphan emptyBranchName\n<span class="token function">git</span> <span class="token function">rm</span> -rf <span class="token builtin class-name">.</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="git提交空文件夹" tabindex="-1"><a class="header-anchor" href="#git提交空文件夹" aria-hidden="true">#</a> git提交空文件夹</h2><p>创建 <code>.gitkeep</code> 文件，内容如下</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code># Ignore everything in this directory\n*\n# Except this file !.gitkeep\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="gerrit" tabindex="-1"><a class="header-anchor" href="#gerrit" aria-hidden="true">#</a> gerrit</h2>',35),_={href:"https://lipeng1667.github.io/2017/01/18/gerrit-guide/",target:"_blank",rel:"noopener noreferrer"},E=(0,n.Uk)("gerrit-guide"),L=(0,n._)("li",null,[(0,n.Uk)("新建分支 "),(0,n._)("code",null,"git push origin HEAD:new-branch")],-1),q=(0,n._)("li",null,[(0,n.Uk)("提交分支 "),(0,n._)("code",null,"git push origin HEAD:/refs/for/new-branch")],-1),w=(0,n.uE)('<h3 id="常见报错" tabindex="-1"><a class="header-anchor" href="#常见报错" aria-hidden="true">#</a> 常见报错</h3><ul><li>no changes <code>git commit --amend</code></li></ul><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><ul><li><p>查看分支：<code>git branch</code></p></li><li><p>创建分支：<code>git branch </code></p></li><li><p>切换分支：<code>git checkout </code></p></li><li><p>创建 切换分支：<code>git checkout -b </code></p></li><li><p>合并某分支到当前分支：<code>git merge </code></p></li><li><p>删除本地分支：<code>git branch -D 分支名</code></p></li><li><p>删除远程分支：<code> git push origin --delete 分支名</code></p></li><li><p>提交：<code>git branch origin 远程分支名称</code></p></li></ul><h3 id="误删分支" tabindex="-1"><a class="header-anchor" href="#误删分支" aria-hidden="true">#</a> 误删分支</h3><p>不小心删除了远程的分支，如何恢复？</p><p>查看 <code>git reflog</code> ，找到恢复的 <code>commitid</code></p><p><code>git reflog --date=iso</code></p><p><code>git reflog</code> 用来记录你的每一次命令，--date=iso 表示以标准时间显示 <strong>如果已删除的分支是落后于远程分支的，就不适用这种方法</strong>。</p><p>#切出分支 git checkout -b feature_EMR2.2.2_guoba commitid 然后再推到远端就有了。</p><h2 id="自定义git" tabindex="-1"><a class="header-anchor" href="#自定义git" aria-hidden="true">#</a> 自定义Git</h2><p>配置命令别名 本节是教你如何偷懒的。 如果敲<code>git st</code>就表示<code>git status</code>那就简单多了，当然这种偷懒的办法我们是极力赞成的。 我们只需要敲一行命令，告诉<code>Git</code>，以后<code>st</code>就表示<code>status</code>：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> config --global alias.st status\n<span class="token function">git</span> config --global alias.pl pull\n<span class="token function">git</span> config --global alias.ps push\n<span class="token function">git</span> config --global alias.ci commit\n<span class="token function">git</span> config --global alias.co checkout\n<span class="token function">git</span> config --global alias.br branch\n<span class="token function">git</span> config --global alias.cp cherry-pick\n<span class="token function">git</span> config --global alias.ss stash\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>当然还有别的命令可以简写，很多人都用<code>co</code>表示<code>checkout</code>，<code>ci</code>表示<code>commit</code>，<code>br</code>表示<code>branch</code></p><h2 id="其它技巧" tabindex="-1"><a class="header-anchor" href="#其它技巧" aria-hidden="true">#</a> 其它技巧</h2><p>之前上传过的文件夹已经提交过了，新加的 <code>.ignore</code>不起作用， 想要忽略怎么办？执行这个，然后正常提交ok <code>git rm -r --cached .</code></p><p>查看某一段代码谁写的 <code>git blame file.js -L 1,2</code></p><h3 id="忽略操作系统尾部换行符" tabindex="-1"><a class="header-anchor" href="#忽略操作系统尾部换行符" aria-hidden="true">#</a> 忽略操作系统尾部换行符</h3><p>从 <code>Windows</code> 更换到 <code>Mac</code>，<code>pull</code> 代码下来修改完提交时 ，提交一个 <code>CRLF</code> 文件到仓库上，这个 <code>CRLF</code> 其实是不同操作系统的尾部换行符的格式，<code>CRLF</code> 是 <code>Carriage Return Line Feed</code> 的缩写，中文意思是回车换行，<code>LF</code> 是 <code>Line Feed</code> 的缩写，中文意思是换行</p><p>假如你正在 <code>Windows</code> 上写程序，又或者你正在和其他人合作，他们在 <code>Windows</code> 上编程，而你却在其他系统上，在这些情况下，就可能会遇到行尾结束符问题，这是因为 <code>Windows</code> 使用回车和换行两个字符来结束一行，而 <code>Mac</code> 和 <code>Linux</code> 只使用换行符一个字符。虽然这是小问题，但它会极大地扰乱跨平台协作，在提交时产生非常多的冲突。</p><p>解决： <code>git config --global core.autocrlf true</code></p><ul><li>true <code>x -&gt; LF -&gt; CRLF</code> <code>Git</code> 可以在你提交时自动地把行结束符 <code>CRLF</code> 转换成 <code>LF</code> ，而在签出代码时把 <code>LF</code> 转换成 <code>CRLF</code> 。设置 <code>core.autocrlf</code> 来打开此项功能，如果是在 <code>Windows</code> 系统上，就把它设置成 <code>true</code> ，这样当签出代码时，<code>LF</code> 会被转换成 <code>CRLF</code></li><li>input <code>x -&gt; LF -&gt; LF</code> <code>Linux</code> 或 <code>Mac</code> 系统使用 <code>LF</code> 作为行结束符，因此你不想 <code>Git</code> 在签出文件时进行自动的转换；当一个以 <code>CRLF</code> 为行结束符的文件不小心被引入时你肯定想进行修正，把 <code>core</code> . <code>autocrlf</code> 设置成 <code>input</code> 来告诉 <code>Git</code> 在提交时把 <code>CRLF</code> 转换成 <code>LF</code> ，签出时不转换, 这样会在 <code>Windows</code> 系统上的签出文件中保留 <code>CRLF</code> ，会在 <code>Mac</code> 和 <code>Linux</code> 系统上，包括仓库中保留 <code>LF</code></li><li>false <code>x -&gt; x -&gt; x</code> 如果你是 <code>Windows</code> 程序员，且正在开发仅运行在 <code>Windows</code> 上的项目，可以设置 <code>false</code> 取消此功能，把回车符记录在库中</li></ul><h2 id="安全重命名" tabindex="-1"><a class="header-anchor" href="#安全重命名" aria-hidden="true">#</a> 安全重命名</h2><p><code>git mv &lt;old-name&gt; &lt;new-name&gt;</code></p><h2 id="并入你最近的一次-commit" tabindex="-1"><a class="header-anchor" href="#并入你最近的一次-commit" aria-hidden="true">#</a> 并入你最近的一次 commit</h2><p><code>git commit --amend --no-edit</code></p><p>这条命令会把你暂存的修改并入你最近的一次 commit，并且不会修改这次 commit 的信息（ 这样 Git 也就不会打开一个文件编辑界面了。 它最经常的用途是修改刚刚提交的 commit。也许我太粗心了， 总是在刚提交完一条 commit 还不到 30 秒，就发现一个拼写错误或者忘了删除了调式信息了</p><h2 id="撤销远程操作" tabindex="-1"><a class="header-anchor" href="#撤销远程操作" aria-hidden="true">#</a> 撤销远程操作</h2><p>已经提交到远程了，不想要了，怎么办？</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> reset --hard <span class="token punctuation">[</span>commit_id<span class="token punctuation">]</span>\n<span class="token function">git</span> push origin <span class="token punctuation">[</span>分支名<span class="token punctuation">]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这个操作非常危险，如果别人也提交了，他的也会不存在</p><h2 id="git-子模块" tabindex="-1"><a class="header-anchor" href="#git-子模块" aria-hidden="true">#</a> git 子模块</h2><h3 id="克隆所有子模块" tabindex="-1"><a class="header-anchor" href="#克隆所有子模块" aria-hidden="true">#</a> 克隆所有子模块</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> clone --recursive git://github.com/foo/bar.git\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>如果已经克隆了</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> submodule update --init --recursive\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="添加" tabindex="-1"><a class="header-anchor" href="#添加" aria-hidden="true">#</a> 添加</h3><p>为当前工程添加submodule，命令如下</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> submodule <span class="token function">add</span> 仓库地址 路径\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>其中，仓库地址是指子模块仓库地址，路径指将子模块放置在当前工程下的路径。 注意：路径不能以 / 结尾（会造成修改不生效）、不能是现有工程已有的目录（不能順利 <code>Clone</code>），不写路径默认当前文件夹</p><p>命令执行完成，会在当前工程根路径下生成一个名为“<code>.gitmodules</code>”的文件，其中记录了子模块的信息。添加完成以后，再将子模块所在的文件夹添加到工程中即可。</p><h3 id="删除" tabindex="-1"><a class="header-anchor" href="#删除" aria-hidden="true">#</a> 删除</h3><p><code>submodule</code>的删除稍微麻烦点：首先，要在“<code>.gitmodules</code>”文件中删除相应配置信息。然后，执行“<code>git rm –cached</code> ”命令将子模块所在的文件从git中删除。</p><h3 id="下载的工程带有submodule" tabindex="-1"><a class="header-anchor" href="#下载的工程带有submodule" aria-hidden="true">#</a> 下载的工程带有submodule</h3><p>当使用<code>git clone</code>下来的工程中带有<code>submodule</code>时，初始的时候，<code>submodule</code>的内容并不会自动下载下来的，此时，只需执行如下命令：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> submodule update --init --recursive\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>即可将子模块内容下载下来后工程才不会缺少相应的文件。</p><h3 id="修改子模块并提交" tabindex="-1"><a class="header-anchor" href="#修改子模块并提交" aria-hidden="true">#</a> 修改子模块并提交</h3><p>进入子模块目录下，进行<code>git add . </code>,<code>git commit -m &quot;&quot;</code>,<code>git push origin origin</code>操作 最后在主模块提交</p><h3 id="添加ssh" tabindex="-1"><a class="header-anchor" href="#添加ssh" aria-hidden="true">#</a> 添加ssh</h3>',50),F=(0,n.Uk)("ssh是什么"),A=(0,n.uE)('<h3 id="git-钩子" tabindex="-1"><a class="header-anchor" href="#git-钩子" aria-hidden="true">#</a> git 钩子</h3><p><code>pre-commit</code> 钩子在键入提交信息前运行。 它用于检查即将提交的快照，例如，检查是否有所遗漏，确保测试运行，以及核查代码。 如果该钩子以非零值退出，Git 将放弃此次提交，不过你可以用 <code>git commit --no-verify </code>来绕过这个环节。 你可以利用该钩子，来检查代码风格是否一致（运行类似 lint 的程序）、尾随空白字符是否存在（自带的钩子就是这么做的），或新方法的文档是否适当。</p><div class="language-json ext-json line-numbers-mode"><pre class="language-json"><code><span class="token property">&quot;pre-commit&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>\n    <span class="token string">&quot;lint&quot;</span>\n  <span class="token punctuation">]</span><span class="token punctuation">,</span>\n  <span class="token property">&quot;scripts&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">&quot;lint&quot;</span><span class="token operator">:</span> <span class="token string">&quot;eslint --ext .js, src&quot;</span><span class="token punctuation">,</span>\n    <span class="token property">&quot;lint:fix&quot;</span><span class="token operator">:</span> <span class="token string">&quot;npm run lint -- --fix&quot;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>git提交前会验证lint命令</p>',4),y=(0,n.Uk)("更多查看"),D={href:"https://github.com/k88hudson/git-flight-rules/blob/master/README_zh-CN.md",target:"_blank",rel:"noopener noreferrer"},G=(0,n.Uk)("https://github.com/k88hudson/git-flight-rules/blob/master/README_zh-CN.md"),C=(0,n.Uk)("在线学习git使用 "),U={href:"https://learngitbranching.js.org/",target:"_blank",rel:"noopener noreferrer"},W=(0,n.Uk)("https://learngitbranching.js.org/"),R=(0,n._)("h2",{id:"今日图",tabindex:"-1"},[(0,n._)("a",{class:"header-anchor",href:"#今日图","aria-hidden":"true"},"#"),(0,n.Uk)(" 今日图")],-1),H=(0,n._)("p",null,[(0,n._)("img",{src:i,alt:"16a8d22958e71066.png"})],-1),B={},$=(0,s(3744).Z)(B,[["render",function(e,a){const s=(0,n.up)("OutboundLink"),i=(0,n.up)("RouterLink");return(0,n.wg)(),(0,n.iD)(n.HY,null,[c,(0,n._)("p",null,[d,t,(0,n._)("a",l,[o,(0,n.Wm)(s)])]),r,(0,n._)("p",null,[(0,n._)("a",h,[p,(0,n.Wm)(s)])]),u,(0,n._)("p",null,[g,b,m,(0,n._)("a",v,[f,(0,n.Wm)(s)]),k]),x,(0,n._)("ul",null,[(0,n._)("li",null,[(0,n._)("a",_,[E,(0,n.Wm)(s)])]),L,q]),w,(0,n._)("ul",null,[(0,n._)("li",null,[(0,n.Wm)(i,{to:"/Utils/Linux/ssh%E6%98%AF%E4%BB%80%E4%B9%88.html"},{default:(0,n.w5)((()=>[F])),_:1})])]),A,(0,n._)("p",null,[y,(0,n._)("a",D,[G,(0,n.Wm)(s)])]),(0,n._)("p",null,[C,(0,n._)("a",U,[W,(0,n.Wm)(s)])]),R,H],64)}]])}}]);