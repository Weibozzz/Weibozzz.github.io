"use strict";(self.webpackChunkweiboqianduan=self.webpackChunkweiboqianduan||[]).push([[1901],{5216:(a,s,e)=>{e.r(s),e.d(s,{data:()=>n});const n={key:"v-6563fbf2",path:"/RegExp/%E5%85%88%E8%A1%8C%E6%96%AD%E8%A8%80%E5%92%8C%E5%90%8E%E8%A1%8C%E6%96%AD%E8%A8%80.html",title:"先行断言和后行断言",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"正则表达式的先行断言和后行断言一共有4种形式：",slug:"正则表达式的先行断言和后行断言一共有4种形式",children:[]},{level:2,title:"今日图 - DNS 劫持",slug:"今日图-dns-劫持",children:[]}],filePathRelative:"RegExp/先行断言和后行断言.md",git:{updatedTime:1627026748e3}}},1383:(a,s,e)=>{e.r(s),e.d(s,{default:()=>c});var n=e(6252);const t=e.p+"assets/img/16a96f4b64f0ad8a.4cb14fd4.gif",o=(0,n.uE)('<h1 id="先行断言和后行断言"><a class="header-anchor" href="#先行断言和后行断言">#</a> 先行断言和后行断言</h1><blockquote><p>正则表达式的先行断言(lookahead)和后行断言(lookbehind)</p></blockquote><h2 id="正则表达式的先行断言和后行断言一共有4种形式"><a class="header-anchor" href="#正则表达式的先行断言和后行断言一共有4种形式">#</a> 正则表达式的先行断言和后行断言一共有4种形式：</h2><ol><li><code> (?=pattern)</code> 零宽正向先行断言(zero-width positive lookahead assertion)</li><li><code>(?!pattern) </code>零宽负向先行断言(zero-width negative lookahead assertion)</li><li><code>(?&lt;=pattern)</code> 零宽正向后行断言(zero-width positive lookbehind assertion)</li><li><code>(?&lt;!pattern)</code> 零宽负向后行断言(zero-width negative lookbehind assertion)</li></ol><p>这里面的<code>pattern</code>是一个正则表达式。</p><p>如同<code>^</code>代表开头，<code>$</code>代表结尾，<code>\\b</code>代表单词边界一样，先行断言和后行断言也有类似的作用，它们只匹配某些位置，在匹配过程中，不占用字符，所以被称为“零宽”。所谓位置，是指字符串中(每行)第一个字符的左边、最后一个字符的右边以及相邻字符的中间（假设文字方向是头左尾右）。下面分别举例来说明这4种断言的含义。</p><ol><li>关于先行(lookahead)和后行(lookbehind)：正则表达式引擎在执行字符串和表达式匹配时，会从头到尾（从前到后）连续扫描字符串中的字符，设想有一个扫描指针指向字符边界处并随匹配过程移动。先行断言，是当扫描指针位于某处时，引擎会尝试匹配指针还未扫过的字符，先于指针到达该字符，故称为先行。后行断言，引擎会尝试匹配指针已扫过的字符，后于指针到达该字符，故称为后行。</li><li>关于正向(positive)和负向(negative)：正向就表示匹配括号中的表达式，负向表示不匹配。</li></ol><p>对这4个断言形式的记忆：</p><ol><li>先行和后行：后行断言<code>(?&lt;=pattern)</code>、<code>(?&lt;!pattern)</code>中，有个小于号，同时也是箭头，对于自左至右的文本方向，这个箭头是指向后的，这也比较符合我们的习惯。把小于号去掉，就是先行断言。</li><li>正向和负向：不等于(!=)、逻辑非(!)都是用!号来表示，所以有!号的形式表示不匹配、负向；将!号换成=号，就表示匹配、正向。</li></ol><p>我们经常用正则表达式来检测一个字符串中包含某个子串，要表示一个字符串中不包含某个字符或某些字符也很容易，用[^...]形式就可以了。要表示一个字符串中不包含某个子串（由字符序列构成）呢？用[^...]这种形式就不行了，这时就要用到（负向）先行断言或后行断言、或同时使用。</p><p>例如判断一句话中包含<code>this</code>，但不包含<code>that</code>。</p><p>包含<code>this</code>比较好办，一句话中不包含<code>that</code>，可以认为这句话中每个字符的前面都不是<code>that</code>或每个字符的后面都不是<code>that</code>。正则表达式如下：<code>^((?&lt;!that).)*this((?&lt;!that).)*$ </code>或 <code>^(.(?!that))*this(.(?!that))*$</code></p><p>对于<code>this is the case</code>这句话，两个表达式都能够匹配成功，而<code>note that this is the case</code>都匹配失败。</p><p>在一般情况下，这两个表达式基本上都能够满足要求了。考虑极端情况，如一句话以<code>that</code>开头、以<code>that</code>结尾、<code>that和this</code>连在一起时，上述表达式就可能不胜任了。</p><p>如<code>note thatthis is the case</code>或者<code>this is the case, not that</code>等。只要灵活运用这几个断言，就很容易解决：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^(.(?&lt;!that))*this(.(?&lt;!that))*$</span><span class="token regex-delimiter">/</span></span>\n\n<span class="token operator">/</span><span class="token operator">^</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">&lt;</span><span class="token operator">!</span>that<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">!</span>that<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">*</span>$<span class="token operator">/</span>\n\n<span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^((?!that).)*this(.(?&lt;!that))*$</span><span class="token regex-delimiter">/</span></span>\n\n<span class="token operator">/</span><span class="token operator">^</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">!</span>that<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">!</span>that<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">*</span>$<span class="token operator">/</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这4个正则表达式测试上述的几句话，结果都能够满足要求。</p><p>上述4种断言，括号里的<code>pattern</code>本身是一个正则表达式。但对2种后行断言有所限制，在<code>Perl和Python</code>中，这个表达式必须是定长(fixed length)的，即不能使用<code>*、+、?</code>等元字符，如<code>(?&lt;=abc)</code>没有问题，但<code>(?&lt;=a*bc)</code>是不被支持的，特别是当表达式中含有|连接的分支时，各个分支的长度必须相同。之所以不支持变长表达式，是因为当引擎检查后行断言时，无法确定要回溯多少步。Java支持<code>?、{m}、{n,m}</code>等符号，但同样不支持<code>*、+</code>字符。<code>Javascript</code>ES6+支持后行断言，</p><h2 id="今日图-dns-劫持"><a class="header-anchor" href="#今日图-dns-劫持">#</a> 今日图 - DNS 劫持</h2><p><img src="'+t+'" alt="16a96f4b64f0ad8a.gif"></p>',20),p={},c=(0,e(3744).Z)(p,[["render",function(a,s){return o}]])}}]);