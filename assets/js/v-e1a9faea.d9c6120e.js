"use strict";(self.webpackChunkweiboqianduan=self.webpackChunkweiboqianduan||[]).push([[1102],{6051:(e,a,d)=>{d.r(a),d.d(a,{data:()=>r});const r={key:"v-e1a9faea",path:"/JS/%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88.html",title:"线程和进程的区别是什么",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"总论",slug:"总论",children:[]},{level:2,title:"下面细说背景",slug:"下面细说背景",children:[]},{level:2,title:"一个最最基础的事实",slug:"一个最最基础的事实",children:[]},{level:2,title:"一个必须知道的事实",slug:"一个必须知道的事实",children:[]},{level:2,title:"串联起来的事实",slug:"串联起来的事实",children:[]},{level:2,title:"总结",slug:"总结",children:[]},{level:2,title:"今日图",slug:"今日图",children:[]}],filePathRelative:"JS/线程和进程的区别是什么.md",git:{updatedTime:1627026748e3}}},3797:(e,a,d)=>{d.r(a),d.d(a,{default:()=>u});var r=d(6252);const t=d.p+"assets/img/assss.3a1a1706.gif",i=(0,r.uE)('<h1 id="线程和进程的区别是什么" tabindex="-1"><a class="header-anchor" href="#线程和进程的区别是什么" aria-hidden="true">#</a> 线程和进程的区别是什么</h1><h2 id="总论" tabindex="-1"><a class="header-anchor" href="#总论" aria-hidden="true">#</a> 总论</h2><blockquote><p>首先来一句概括的总论：<strong>进程和线程都是一个时间段的描述，是<code>CPU</code>工作时间段的描述</strong>。</p></blockquote><h2 id="下面细说背景" tabindex="-1"><a class="header-anchor" href="#下面细说背景" aria-hidden="true">#</a> 下面细说背景</h2><p><code>CPU</code>+<code>RAM</code>+各种资源（比如显卡，光驱，键盘，<code>GPS</code>, 等等外设）构成我们的电脑，但是电脑的运行，实际就是<code>CPU</code>和相关寄存器以及<code>RAM</code>之间的事情。</p><h2 id="一个最最基础的事实" tabindex="-1"><a class="header-anchor" href="#一个最最基础的事实" aria-hidden="true">#</a> 一个最最基础的事实</h2><p><code>CPU</code>太快，太快，太快了，寄存器仅仅能够追的上他的脚步，<code>RAM</code>和别的挂在各总线上的设备完全是望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在<code>CPU</code>看来就是轮流着来。</p><h2 id="一个必须知道的事实" tabindex="-1"><a class="header-anchor" href="#一个必须知道的事实" aria-hidden="true">#</a> 一个必须知道的事实</h2><p>执行一段程序代码，实现一个功能的过程介绍 ，当得到<code>CPU</code>的时候，相关的资源必须也已经就位，就是显卡啊，<code>GPS</code>啊什么的必须就位，然后CPU开始执行。这里除了CPU以外所有的就构成了这个程序的执行环境，也就是我们所定义的程序上下文。当这个程序执行完了，或者分配给他的CPU执行时间用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他被<code>CPU</code>临幸的运行环境，必须保存。</p><h2 id="串联起来的事实" tabindex="-1"><a class="header-anchor" href="#串联起来的事实" aria-hidden="true">#</a> 串联起来的事实</h2><p>前面讲过在<code>CPU</code>看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：<strong>先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文</strong>。。。。</p><p><strong>========= 重要的东西出现了========</strong></p><p>进程和线程就是这样的背景出来的，<strong>两个名词不过是对应的CPU时间段的描述，名词就是这样的功能</strong>。</p><ul><li>进程就是包换上下文切换的程序执行时间总和 = CPU加载上下文+CPU执行+CPU保存上下文</li><li>线程是什么呢？进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：程序A得到CPU =》CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的。这里的<strong>a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段</strong>。</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p><strong>进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同</strong>。</p>',16),h=(0,r.Uk)("摘自"),n={href:"https://www.zhihu.com/question/25532384",target:"_blank",rel:"noopener noreferrer"},l=(0,r.Uk)("https://www.zhihu.com/question/25532384"),c=(0,r._)("h2",{id:"今日图",tabindex:"-1"},[(0,r._)("a",{class:"header-anchor",href:"#今日图","aria-hidden":"true"},"#"),(0,r.Uk)(" 今日图")],-1),o=(0,r._)("p",null,[(0,r._)("img",{src:t,alt:"assss.gif"})],-1),s={},u=(0,d(3744).Z)(s,[["render",function(e,a){const d=(0,r.up)("OutboundLink");return(0,r.wg)(),(0,r.iD)(r.HY,null,[i,(0,r._)("p",null,[h,(0,r._)("a",n,[l,(0,r.Wm)(d)])]),c,o],64)}]])}}]);