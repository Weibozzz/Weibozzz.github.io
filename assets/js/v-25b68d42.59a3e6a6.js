"use strict";(self.webpackChunkweiboqianduan=self.webpackChunkweiboqianduan||[]).push([[8501],{1644:(e,d,o)=>{o.r(d),o.d(d,{data:()=>l});const l={key:"v-25b68d42",path:"/HTTP/HTTP%E5%8D%8F%E8%AE%AE.html",title:"HTTP协议",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"特点",slug:"特点",children:[]},{level:2,title:"报文",slug:"报文",children:[]},{level:2,title:"请求方法",slug:"请求方法",children:[{level:3,title:"get和post的区别",slug:"get和post的区别",children:[]},{level:3,title:"状态码",slug:"状态码",children:[]}]},{level:2,title:"持久连接",slug:"持久连接",children:[]},{level:2,title:"管线化",slug:"管线化",children:[]},{level:2,title:"今日图 520扎心了",slug:"今日图-520扎心了",children:[]}],filePathRelative:"HTTP/HTTP协议.md",git:{updatedTime:1626767622e3}}},7549:(e,d,o)=>{o.r(d),o.d(d,{default:()=>n});var l=o(6252);const c=o.p+"assets/img/123_20190521095200.d6137d5c.jpg",i=(0,l.uE)('<h1 id="http协议" tabindex="-1"><a class="header-anchor" href="#http协议" aria-hidden="true">#</a> HTTP协议</h1><h2 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h2><ol><li>简单快速 ：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有<code>GET</code>、<code>HEAD</code>、<code>POST</code>。每种方法规定了客户与服务器联系的类型不同。由于<code>HTTP</code>协议简单，使得<code>HTTP</code>服务器的程序规模小，因而通信速度很快。</li><li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记</li><li>连接： 无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>无状态：<code>HTTP</code>协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li></ol><h2 id="报文" tabindex="-1"><a class="header-anchor" href="#报文" aria-hidden="true">#</a> 报文</h2><ul><li>请求报文：请求行，请求头，空行，请求体</li><li>响应报文：状态行，响应头，空行，响应体</li></ul><h2 id="请求方法" tabindex="-1"><a class="header-anchor" href="#请求方法" aria-hidden="true">#</a> 请求方法</h2><ol><li><code>GET</code> 请求指定的页面信息，并返回实体主体。</li><li><code>HEAD</code> 类似于<code>get</code>请求，只不过返回的响应中没有具体的内容，用于获取报头</li><li><code>POST</code> 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。<code>POST</code>请求可能会导致新的资源的建立和/或已有资源的修改。</li><li><code>PUT</code> 从客户端向服务器传送的数据取代指定的文档的内容。</li><li><code>DELETE</code> 请求服务器删除指定的页面。</li><li><code>CONNECT</code> <code>HTTP/1.1</code>协议中预留给能够将连接改为管道方式的代理服务器。</li><li><code>OPTIONS</code> 允许客户端查看服务器的性能。</li><li><code>TRACE</code> 回显服务器收到的请求，主要用于测试或诊断。</li></ol><h3 id="get和post的区别" tabindex="-1"><a class="header-anchor" href="#get和post的区别" aria-hidden="true">#</a> get和post的区别</h3><ol><li><code>get</code>在浏览器回退时是无害的，<code>post</code>会再次提交请求</li><li><code>get</code>的url可以收藏，<code>post</code>不可以</li><li><code>get</code>请求会主动缓存，<code>post</code>不会，除非手动设置</li></ol><h3 id="状态码" tabindex="-1"><a class="header-anchor" href="#状态码" aria-hidden="true">#</a> 状态码</h3><ul><li>1xx：指示信息--表示请求已接收，继续处理</li><li>2xx：成功--表示请求已被成功接收、理解、接受</li><li>3xx：重定向--要完成请求必须进行更进一步的操作</li><li>4xx：客户端错误--请求有语法错误或请求无法实现</li><li>5xx：服务器端错误--服务器未能实现合法的请求</li></ul>',11),t={href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/206",target:"_blank",rel:"noopener noreferrer"},a=(0,l.Uk)("more"),r=(0,l.uE)('<h2 id="持久连接" tabindex="-1"><a class="header-anchor" href="#持久连接" aria-hidden="true">#</a> 持久连接</h2><p>什么是持久连接？对于<code>HTTP</code>协议而言，它是基于请求响应模型，<code>Client</code>向<code>Server</code>发请求时，先建立一条<code>HTTP</code>连接，<code>Server</code>给<code>Client</code>响应数据后，连接关闭。</p><p>当<code>Client</code>发送下一个请求时，需要重新再建立<code>HTTP</code>连接，这种方式就是：一个请求响应需要占用一条HTTP连接。而持久连接就是：只需要建立一条连接，然后在这条连接上 传输多个请求和响应。</p><p>与持久连接相关的字段 <code>HTTP1.0</code>中有一个<code>Connection</code>首部字段，它是一个逐跳首部字段。<code>Connection:Keep-Alive</code>，表示希望将此条连接作为持久连接。 <code>HTTP1.1</code>中，建立的<code>HTTP</code>请求默认是持久连接的。当<code>Client</code>确定不再需要向<code>Server</code>发送数据时，它可以关闭连接，即在发送首部中添加<code>Connection:Closed</code>字段。</p><h2 id="管线化" tabindex="-1"><a class="header-anchor" href="#管线化" aria-hidden="true">#</a> 管线化</h2><ul><li>①管线化机制通过持久连接完成，仅<code>HTTP/1.1</code>支持此技术</li><li>②只有<code>GET</code>和<code>HEAD</code>请求可以进行管线化，而<code>POST</code>会有所限制</li><li>③初次创建连接时不应启动管线机制，因为对方服务器不一定支持<code>HTTP/1.1</code>版本的协议</li></ul><p>持久连接的时候，某个连接消息传递类似于 持久连接的一个最大的好处是：大大减少了连接的建立以及关闭时延。 “缺点”，请求响应是顺序执行的。只有在请求1的响应收到之后，才会发送请求2，这就是持久连接与管道化连接不同的地方。 <code>请求1=&gt;响应1=&gt;请求2=&gt;响应2</code></p><p>管线化后 <code>请求1=&gt;请求2=&gt;响应1=&gt;响应2</code></p><p>管道化连接是需要持久连接支持的。管道化连接是在持久连接的基础上，以“流水线”的方式发送请求：不需要等到请求1的响应到达<code>Client</code>，就可以发送请求2....</p><h2 id="今日图-520扎心了" tabindex="-1"><a class="header-anchor" href="#今日图-520扎心了" aria-hidden="true">#</a> 今日图 520扎心了</h2><p><img src="'+c+'" alt="123_20190521095200.jpg"></p>',11),h={},n=(0,o(3744).Z)(h,[["render",function(e,d){const o=(0,l.up)("OutboundLink");return(0,l.wg)(),(0,l.iD)(l.HY,null,[i,(0,l._)("p",null,[(0,l._)("a",t,[a,(0,l.Wm)(o)])]),r],64)}]])}}]);